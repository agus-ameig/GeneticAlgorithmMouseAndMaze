import mazeimport maze_samplesimport randomclass GA:    def __init__(self, maze_number, mutation_rate, pop_size):        self.maze_number = maze_number        self.pop_size = pop_size        self.mutation_rate = mutation_rate        self.pop = Population(self.pop_size, self.maze_number)  # choose how many individuals to put in a population    def cross_breed(self, p1, p2):        p1_moves = p1.get_moves()  # gets moves from both parents        p2_moves = p2.get_moves()        b = random.randint(0, len(p1_moves))  # choose a random breakpoint in the string to copy dna from        baby1 = Individual(len(p1_moves), self.maze_number, list((p1_moves[0:b] + p2_moves[b:])))        baby2 = Individual(len(p1_moves), self.maze_number, list((p2_moves[0:b] + p1_moves[b:])))        return baby1, baby2    def mutate(self, m, individual):  # change one chromosome in individual randomly (given correct mutation rate)        r = random.randrange(0, 100)        if r < m:            idx = random.randrange(0, len(individual.get_moves()))            change = individual.possible_moves[random.randrange(0, len(individual.possible_moves))]            individual.moves[idx] = change            return individual        else:            return individual  # if it isn't mutated, it returns the original individual    def SetWeightsForMonteCarloSelection(self, values):        # Take a list of values        # Normalize using sum(values)        # Transform each value to rounded integer        # The greater this value, the more likely to be selected (a weighting)        # Transform values to accumulated selection weights        normalized_values = [int(v / sum(values) * 100 + .5) for v in values]        accum = 0        selection_weights = []        for w in normalized_values:            accum += w            selection_weights.append(accum)        return selection_weights    def MonteCarloSelection(self, selection_weights):        selection = random.randint(0, selection_weights[-1])        for i, w in enumerate(selection_weights):            if selection <= w:                return i    def evolve(self, num_generations):  # evolves each individual x generations        population = self.pop.get_population()        for gen in range(0, num_generations):            individuals_with_fitness = []            if gen == 0:                for p in population:                    individuals_with_fitness.append([p, p.get_fitness()])  # sets up initial evolution            else:                individuals_with_fitness = new_gen            new_gen = []            for i in range(len(individuals_with_fitness) // 2):                p1_index = self.MonteCarloSelection(self.SetWeightsForMonteCarloSelection(                    [f[1] for f in individuals_with_fitness]))                p2_index = self.MonteCarloSelection(self.SetWeightsForMonteCarloSelection(                    [f[1] for f in individuals_with_fitness]))                p1 = individuals_with_fitness[p1_index][0]                p2 = individuals_with_fitness[p2_index][0]                babies = self.cross_breed(p1, p2)                baby1 = self.mutate(self.mutation_rate, babies[0])                baby2 = self.mutate(self.mutation_rate, babies[0])                new_gen.append([baby1, baby1.get_fitness()])                new_gen.append([baby2, baby2.get_fitness()])        print("Final Individual: ", individuals_with_fitness[0][0].get_moves(), " ", individuals_with_fitness[0][0].get_fitness())        return individuals_with_fitness[0][0].get_moves()class Individual:    def __init__(self, dna_length, maze_number, moves=[]):  # creates a new individual with a set of moves        self.maze_number = maze_number        self.possible_moves = ['U', 'D', 'R', 'L']        # find starting position ('M')        for row in range(0, len(maze_samples.maze[self.maze_number])):            if 'M' in maze_samples.maze[self.maze_number][row]:                self.location = maze_samples.maze[self.maze_number][row].index('M')                self.row = row        if moves:  # initialize individual with a set of moves            self.moves = moves        else:            self.moves = []  # if no moves are provided, create an individual with randomly generated moves            for i in range(0, dna_length * 2):  # create a list of moves (multiplied by 2 for more moves)                self.moves.append(self.possible_moves[random.randrange(0, 4)])        self.score = 0  # init individual with a fitness score of 0    def get_moves(self):  # get the moves in string format        return str(''.join(self.moves))    def get_fitness(self):        moves = self.get_moves()  # gets a string of the individual's moves        max_row_size = len(maze_samples.maze[self.maze_number])  # gets the max row size from the given grid        max_loc_size = len(maze_samples.maze[self.maze_number][0])  # gets the max column size from the given grid        for move in moves:  # checks each move for certain conditions            if move == 'U' and not self.row + 1 >= max_row_size:  # checks the grid position that goes 'up'                if maze_samples.maze[self.maze_number][self.row + 1][self.location] == '-':                    self.score += 1                    self.row = self.row + 1                    self.location = self.location                elif maze_samples.maze[self.maze_number][self.row + 1][self.location] == 'C':                    self.score += 1                    self.score += len(moves)                elif self.row + 1 > len(maze_samples.maze[self.maze_number]):                    self.score += 0                else:                    self.score += 0            elif move == 'D' and not self.row - 1 < 0:                if maze_samples.maze[self.maze_number][self.row - 1][self.location] == '-':                    self.score += 1                    self.row = self.row - 1                    self.location = self.location                elif maze_samples.maze[self.maze_number][self.row - 1][self.location] == 'C':                    self.score += 1                    self.score += len(moves)                else:                    self.score += 0            elif move == 'L' and not self.location - 1 < 0:                if self.location - 1 > len(maze_samples.maze[self.maze_number][self.row]) or self.location - 1 < 0:                    self.score += 0                elif maze_samples.maze[self.maze_number][self.row][self.location - 1] == '-':                    self.score += 1                    self.row = self.row                    self.location = self.location - 1                elif maze_samples.maze[self.maze_number][self.row][self.location - 1] == 'C':                    self.score += 1                    self.score += len(moves)                elif self.location + 1 > len(maze_samples.maze[self.maze_number][self.row]):                    self.score += 0                else:                    self.score += 0            elif move == 'R' and not self.location + 1 >= max_loc_size:                if maze_samples.maze[self.maze_number][self.row][self.location + 1] == '-':                    self.score += 1                    self.row = self.row                    self.location = self.location + 1                elif maze_samples.maze[self.maze_number][self.row][self.location + 1] == 'C':                    self.score += 1                    self.score += len(moves)                elif self.location - 1 < 0:                    self.score += 0                else:                    self.score += 0            else:                self.score += 0        return self.scoreclass Population:    def __init__(self, num_individuals, maze_number):        self.maze_number = maze_number        self.population = []        self.numIndividuals = num_individuals        for i in range(self.numIndividuals):            indiv = Individual(maze_samples.string_length[self.maze_number], self.maze_number)            self.population.append(indiv)    def get_population(self):        return self.populationdef main():    # There are currently 2 samples in maze_samples.py    test_case = 0    m = maze.Maze(maze_samples.maze[test_case])    m.Visualize()    mutation_rate = 12    num_generations = 120    pop_size = 100    g = GA(test_case, mutation_rate, pop_size)    print("Retrieving most fit individual using genetic algorithm...")    m.RunMaze(g.evolve(num_generations))    x = input("ENTER to continue.")if __name__ == '__main__':    main()"""Programming Exam #2: Genetic AlgorithmCSCI 1133 Ansh Sikka"""